"use client"

import { useState } from "react"
import { useWallet } from "@/lib/wallet-context"
import { CONTRACTS, STELLAR_CONFIG, NETWORK_PASSPHRASE } from "@/lib/contracts-config"
import * as StellarSdk from "@stellar/stellar-sdk"

export function useEnergyDistribution() {
  const { address, kit } = useWallet()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  /**
   * Get member information
   */
  const getMemberInfo = async (memberAddress?: string) => {
    try {
      setIsLoading(true)
      setError(null)

      const targetAddress = memberAddress || address
      if (!targetAddress) {
        throw new Error("No wallet connected")
      }

      if (!CONTRACTS.ENERGY_DISTRIBUTION) {
        throw new Error("Energy distribution contract not configured")
      }

      const server = new StellarSdk.rpc.Server(STELLAR_CONFIG.RPC_URL)
      const contract = new StellarSdk.Contract(CONTRACTS.ENERGY_DISTRIBUTION)
      const account = await server.getAccount(targetAddress)

      // Get member percent
      const percentTx = new StellarSdk.TransactionBuilder(account, {
        fee: StellarSdk.BASE_FEE,
        networkPassphrase: NETWORK_PASSPHRASE,
      })
        .addOperation(
          contract.call(
            "get_member_percent",
            StellarSdk.nativeToScVal(targetAddress, { type: "address" })
          )
        )
        .setTimeout(30)
        .build()

      const percentResult = await server.simulateTransaction(percentTx)

      if (StellarSdk.rpc.Api.isSimulationSuccess(percentResult)) {
        const percent = StellarSdk.scValToNative(percentResult.result!.retval)
        return {
          isMember: percent !== null,
          percent: percent || 0,
        }
      }

      return { isMember: false, percent: 0 }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error"
      setError(errorMessage)
      console.error("Error getting member info:", err)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  /**
   * Get total kWh generated by the community
   */
  const getTotalGenerated = async (): Promise<number> => {
    try {
      setIsLoading(true)
      setError(null)

      if (!CONTRACTS.ENERGY_DISTRIBUTION) {
        throw new Error("Energy distribution contract not configured")
      }

      if (!address) {
        throw new Error("No wallet connected")
      }

      const server = new StellarSdk.rpc.Server(STELLAR_CONFIG.RPC_URL)
      const contract = new StellarSdk.Contract(CONTRACTS.ENERGY_DISTRIBUTION)
      const account = await server.getAccount(address)

      const transaction = new StellarSdk.TransactionBuilder(account, {
        fee: StellarSdk.BASE_FEE,
        networkPassphrase: NETWORK_PASSPHRASE,
      })
        .addOperation(contract.call("get_total_generated"))
        .setTimeout(30)
        .build()

      const simulatedResult = await server.simulateTransaction(transaction)

      if (StellarSdk.rpc.Api.isSimulationSuccess(simulatedResult)) {
        const total = StellarSdk.scValToNative(simulatedResult.result!.retval)
        // Convert from 7 decimals to readable format
        return Number(total) / 10000000
      }

      throw new Error("Failed to get total generated")
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error"
      setError(errorMessage)
      console.error("Error getting total generated:", err)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  /**
   * Get list of community members
   */
  const getMemberList = async (): Promise<string[]> => {
    try {
      setIsLoading(true)
      setError(null)

      if (!CONTRACTS.ENERGY_DISTRIBUTION) {
        throw new Error("Energy distribution contract not configured")
      }

      if (!address) {
        throw new Error("No wallet connected")
      }

      const server = new StellarSdk.rpc.Server(STELLAR_CONFIG.RPC_URL)
      const contract = new StellarSdk.Contract(CONTRACTS.ENERGY_DISTRIBUTION)
      const account = await server.getAccount(address)

      const transaction = new StellarSdk.TransactionBuilder(account, {
        fee: StellarSdk.BASE_FEE,
        networkPassphrase: NETWORK_PASSPHRASE,
      })
        .addOperation(contract.call("get_member_list"))
        .setTimeout(30)
        .build()

      const simulatedResult = await server.simulateTransaction(transaction)

      if (StellarSdk.rpc.Api.isSimulationSuccess(simulatedResult)) {
        const members = StellarSdk.scValToNative(simulatedResult.result!.retval)
        return members as string[]
      }

      throw new Error("Failed to get member list")
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error"
      setError(errorMessage)
      console.error("Error getting member list:", err)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  /**
   * Record energy generation (Admin only)
   */
  const recordGeneration = async (kwhGenerated: number): Promise<string> => {
    try {
      setIsLoading(true)
      setError(null)

      if (!address || !kit) {
        throw new Error("No wallet connected")
      }

      if (!CONTRACTS.ENERGY_DISTRIBUTION) {
        throw new Error("Energy distribution contract not configured")
      }

      // Convert kWh to contract format (7 decimals)
      const kwhInStroops = Math.floor(kwhGenerated * 10000000)

      const server = new StellarSdk.rpc.Server(STELLAR_CONFIG.RPC_URL)
      const contract = new StellarSdk.Contract(CONTRACTS.ENERGY_DISTRIBUTION)
      const account = await server.getAccount(address)

      const transaction = new StellarSdk.TransactionBuilder(account, {
        fee: "100000",
        networkPassphrase: NETWORK_PASSPHRASE,
      })
        .addOperation(
          contract.call(
            "record_generation",
            StellarSdk.nativeToScVal(kwhInStroops, { type: "i128" })
          )
        )
        .setTimeout(30)
        .build()

      const preparedTx = await server.prepareTransaction(transaction)
      const { signedTxXdr } = await kit.signTransaction(preparedTx.toXDR())
      const signedTransaction = StellarSdk.TransactionBuilder.fromXDR(
        signedTxXdr,
        NETWORK_PASSPHRASE
      )

      const result = await server.sendTransaction(signedTransaction as StellarSdk.Transaction)

      if (result.status === "PENDING") {
        let getResponse = await server.getTransaction(result.hash)

        while (getResponse.status === "NOT_FOUND") {
          await new Promise(resolve => setTimeout(resolve, 1000))
          getResponse = await server.getTransaction(result.hash)
        }

        if (getResponse.status === "SUCCESS") {
          return result.hash
        }
      }

      throw new Error("Transaction failed")
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error"
      setError(errorMessage)
      console.error("Error recording generation:", err)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  return {
    getMemberInfo,
    getMemberList,
    getTotalGenerated,
    recordGeneration,
    isLoading,
    error,
  }
}
